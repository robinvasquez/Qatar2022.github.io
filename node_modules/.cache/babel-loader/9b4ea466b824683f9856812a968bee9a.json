{"ast":null,"code":"/*!\n  * vuefire v2.2.5\n  * (c) 2020 Eduardo San Martin Morote\n  * @license MIT\n  */\n\n/**\r\n * Walks a path inside an object\r\n * walkGet({ a: { b: true }}), 'a.b') -> true\r\n * @param obj\r\n * @param path\r\n */\nfunction walkGet(obj, path) {\n  // TODO: development warning when target[key] does not exist\n  return path.split('.').reduce(function (target, key) {\n    return target[key];\n  }, obj);\n}\n/**\r\n * Deeply set a property in an object with a string path\r\n * walkSet({ a: { b: true }}, 'a.b', false)\r\n * @param obj\r\n * @param path\r\n * @param value\r\n * @returns an array with the element that was replaced or the value that was set\r\n */\n\n\nfunction walkSet(obj, path, value) {\n  // path can be a number\n  var keys = ('' + path).split('.');\n  var key = keys.pop(); // split will produce at least one element array\n\n  var target = keys.reduce(function (target, key) {\n    // TODO: dev errors\n    return target[key];\n  }, obj);\n  return Array.isArray(target) ? target.splice(Number(key), 1, value) : target[key] = value;\n}\n/**\r\n * Checks if a variable is an object\r\n * @param o\r\n */\n\n\nfunction isObject(o) {\n  return o && typeof o === 'object';\n}\n/**\r\n * Checks if a variable is a Date\r\n * @param o\r\n */\n\n\nfunction isTimestamp(o) {\n  return o.toDate;\n}\n/**\r\n * Checks if a variable is a Firestore Document Reference\r\n * @param o\r\n */\n\n\nfunction isDocumentRef(o) {\n  return o && o.onSnapshot;\n}\n/**\r\n * Wraps a function so it gets called only once\r\n * @param fn Function to be called once\r\n * @param argFn Function to compute the argument passed to fn\r\n */\n\n\nfunction callOnceWithArg(fn, argFn) {\n  /** @type {boolean | undefined} */\n  var called = false;\n  return function () {\n    if (!called) {\n      called = true;\n      return fn(argFn());\n    }\n  };\n}\n/**\r\n * Convert firebase RTDB snapshot into a bindable data record.\r\n *\r\n * @param snapshot\r\n * @return\r\n */\n\n\nfunction createRecordFromRTDBSnapshot(snapshot) {\n  var value = snapshot.val();\n  var res = isObject(value) ? value : Object.defineProperty({}, '.value', {\n    value: value\n  }); // if (isObject(value)) {\n  //   res = value\n  // } else {\n  //   res = {}\n  //   Object.defineProperty(res, '.value', { value })\n  // }\n\n  Object.defineProperty(res, '.key', {\n    value: snapshot.key\n  });\n  return res;\n}\n/**\r\n * Find the index for an object with given key.\r\n *\r\n * @param array\r\n * @param key\r\n * @return the index where the key was found\r\n */\n\n\nfunction indexForKey(array, key) {\n  for (var i = 0; i < array.length; i++) {\n    if (array[i]['.key'] === key) return i;\n  }\n\n  return -1;\n}\n\nvar DEFAULT_OPTIONS = {\n  reset: true,\n  serialize: createRecordFromRTDBSnapshot,\n  wait: false\n};\n/**\r\n * Binds a RTDB reference as an object\r\n * @param param0\r\n * @param options\r\n * @returns a function to be called to stop listeninng for changes\r\n */\n\nfunction rtdbBindAsObject(_a, extraOptions) {\n  var vm = _a.vm,\n      key = _a.key,\n      document = _a.document,\n      resolve = _a.resolve,\n      reject = _a.reject,\n      ops = _a.ops;\n\n  if (extraOptions === void 0) {\n    extraOptions = DEFAULT_OPTIONS;\n  }\n\n  var options = Object.assign({}, DEFAULT_OPTIONS, extraOptions);\n  var listener = document.on('value', function (snapshot) {\n    ops.set(vm, key, options.serialize(snapshot));\n  }, reject);\n  document.once('value', resolve);\n  return function (reset) {\n    document.off('value', listener);\n\n    if (reset !== false) {\n      var value = typeof reset === 'function' ? reset() : null;\n      ops.set(vm, key, value);\n    }\n  };\n}\n/**\r\n * Binds a RTDB reference or query as an array\r\n * @param param0\r\n * @param options\r\n * @returns a function to be called to stop listeninng for changes\r\n */\n\n\nfunction rtdbBindAsArray(_a, extraOptions) {\n  var vm = _a.vm,\n      key = _a.key,\n      collection = _a.collection,\n      resolve = _a.resolve,\n      reject = _a.reject,\n      ops = _a.ops;\n\n  if (extraOptions === void 0) {\n    extraOptions = DEFAULT_OPTIONS;\n  }\n\n  var options = Object.assign({}, DEFAULT_OPTIONS, extraOptions);\n  var array = options.wait ? [] : ops.set(vm, key, []);\n  var childAdded = collection.on('child_added', function (snapshot, prevKey) {\n    var index = prevKey ? indexForKey(array, prevKey) + 1 : 0;\n    ops.add(array, index, options.serialize(snapshot));\n  }, reject);\n  var childRemoved = collection.on('child_removed', function (snapshot) {\n    ops.remove(array, indexForKey(array, snapshot.key));\n  }, reject);\n  var childChanged = collection.on('child_changed', function (snapshot) {\n    ops.set(array, indexForKey(array, snapshot.key), options.serialize(snapshot));\n  }, reject);\n  var childMoved = collection.on('child_moved', function (snapshot, prevKey) {\n    var index = indexForKey(array, snapshot.key);\n    var oldRecord = ops.remove(array, index)[0];\n    var newIndex = prevKey ? indexForKey(array, prevKey) + 1 : 0;\n    ops.add(array, newIndex, oldRecord);\n  }, reject);\n  collection.once('value', function (data) {\n    if (options.wait) ops.set(vm, key, array);\n    resolve(data);\n  });\n  return function (reset) {\n    collection.off('child_added', childAdded);\n    collection.off('child_changed', childChanged);\n    collection.off('child_removed', childRemoved);\n    collection.off('child_moved', childMoved);\n\n    if (reset !== false) {\n      var value = typeof reset === 'function' ? reset() : [];\n      ops.set(vm, key, value);\n    }\n  };\n} // TODO: fix type not to be any\n\n\nfunction createSnapshot(doc) {\n  // TODO: it should create a deep copy instead because otherwise we will modify internal data\n  // defaults everything to false, so no need to set\n  return Object.defineProperty(doc.data() || {}, 'id', {\n    value: doc.id\n  });\n}\n\nfunction extractRefs(doc, oldDoc, subs) {\n  var dataAndRefs = [{}, {}];\n  var subsByPath = Object.keys(subs).reduce(function (resultSubs, subKey) {\n    var sub = subs[subKey];\n    resultSubs[sub.path] = sub.data();\n    return resultSubs;\n  }, {});\n\n  function recursiveExtract(doc, oldDoc, path, result) {\n    // make it easier to later on access the value\n    oldDoc = oldDoc || {};\n    var data = result[0],\n        refs = result[1]; // Add all properties that are not enumerable (not visible in the for loop)\n    // getOwnPropertyDescriptors does not exist on IE\n\n    Object.getOwnPropertyNames(doc).forEach(function (propertyName) {\n      var descriptor = Object.getOwnPropertyDescriptor(doc, propertyName);\n\n      if (descriptor && !descriptor.enumerable) {\n        Object.defineProperty(data, propertyName, descriptor);\n      }\n    }); // recursively traverse doc to copy values and extract references\n\n    for (var key in doc) {\n      var ref = doc[key];\n\n      if ( // primitives\n      ref == null || // Firestore < 4.13\n      ref instanceof Date || isTimestamp(ref) || ref.longitude && ref.latitude // GeoPoint\n      ) {\n        data[key] = ref;\n      } else if (isDocumentRef(ref)) {\n        // allow values to be null (like non-existant refs)\n        // TODO: better typing since this isObject shouldn't be necessary but it doesn't work\n        data[key] = typeof oldDoc === 'object' && key in oldDoc && // only copy refs if they were refs before\n        // https://github.com/vuejs/vuefire/issues/831\n        typeof oldDoc[key] != 'string' ? oldDoc[key] : ref.path; // TODO: handle subpathes?\n\n        refs[path + key] = ref;\n      } else if (Array.isArray(ref)) {\n        data[key] = Array(ref.length); // fill existing refs into data but leave the rest empty\n\n        for (var i = 0; i < ref.length; i++) {\n          var newRef = ref[i]; // TODO: this only works with array of primitives but not with nested properties like objects with References\n\n          if (newRef && newRef.path in subsByPath) data[key][i] = subsByPath[newRef.path];\n        } // the oldArray is in this case the same array with holes unless the array already existed\n\n\n        recursiveExtract(ref, oldDoc[key] || data[key], path + key + '.', [data[key], refs]);\n      } else if (isObject(ref)) {\n        data[key] = {};\n        recursiveExtract(ref, oldDoc[key], path + key + '.', [data[key], refs]);\n      } else {\n        data[key] = ref;\n      }\n    }\n  }\n\n  recursiveExtract(doc, oldDoc, '', dataAndRefs);\n  return dataAndRefs;\n}\n\nvar DEFAULT_OPTIONS$1 = {\n  maxRefDepth: 2,\n  reset: true,\n  serialize: createSnapshot,\n  wait: false\n};\n\nfunction unsubscribeAll(subs) {\n  for (var sub in subs) {\n    subs[sub].unsub();\n  }\n}\n\nfunction updateDataFromDocumentSnapshot(options, target, path, snapshot, subs, ops, depth, resolve) {\n  var _a = extractRefs(options.serialize(snapshot), walkGet(target, path), subs),\n      data = _a[0],\n      refs = _a[1];\n\n  ops.set(target, path, data);\n  subscribeToRefs(options, target, path, subs, refs, ops, depth, resolve);\n}\n\nfunction subscribeToDocument(_a, options) {\n  var ref = _a.ref,\n      target = _a.target,\n      path = _a.path,\n      depth = _a.depth,\n      resolve = _a.resolve,\n      ops = _a.ops;\n  var subs = Object.create(null);\n  var unbind = ref.onSnapshot(function (snapshot) {\n    if (snapshot.exists) {\n      updateDataFromDocumentSnapshot(options, target, path, snapshot, subs, ops, depth, resolve);\n    } else {\n      ops.set(target, path, null);\n      resolve();\n    }\n  });\n  return function () {\n    unbind();\n    unsubscribeAll(subs);\n  };\n} // NOTE: not convinced by the naming of subscribeToRefs and subscribeToDocument\n// first one is calling the other on every ref and subscribeToDocument may call\n// updateDataFromDocumentSnapshot which may call subscribeToRefs as well\n\n\nfunction subscribeToRefs(options, target, path, subs, refs, ops, depth, resolve) {\n  var refKeys = Object.keys(refs);\n  var missingKeys = Object.keys(subs).filter(function (refKey) {\n    return refKeys.indexOf(refKey) < 0;\n  }); // unbind keys that are no longer there\n\n  missingKeys.forEach(function (refKey) {\n    subs[refKey].unsub();\n    delete subs[refKey];\n  });\n  if (!refKeys.length || ++depth > options.maxRefDepth) return resolve(path);\n  var resolvedCount = 0;\n  var totalToResolve = refKeys.length;\n  var validResolves = Object.create(null);\n\n  function deepResolve(key) {\n    if (key in validResolves) {\n      if (++resolvedCount >= totalToResolve) resolve(path);\n    }\n  }\n\n  refKeys.forEach(function (refKey) {\n    var sub = subs[refKey];\n    var ref = refs[refKey];\n    var docPath = path + \".\" + refKey;\n    validResolves[docPath] = true; // unsubscribe if bound to a different ref\n\n    if (sub) {\n      if (sub.path !== ref.path) sub.unsub(); // if has already be bound and as we always walk the objects, it will work\n      else return;\n    }\n\n    subs[refKey] = {\n      data: function () {\n        return walkGet(target, docPath);\n      },\n      unsub: subscribeToDocument({\n        ref: ref,\n        target: target,\n        path: docPath,\n        depth: depth,\n        ops: ops,\n        resolve: deepResolve.bind(null, docPath)\n      }, options),\n      path: ref.path\n    };\n  });\n} // TODO: refactor without using an object to improve size like the other functions\n\n\nfunction bindCollection(_a, extraOptions) {\n  var vm = _a.vm,\n      key = _a.key,\n      collection = _a.collection,\n      ops = _a.ops,\n      resolve = _a.resolve,\n      reject = _a.reject;\n\n  if (extraOptions === void 0) {\n    extraOptions = DEFAULT_OPTIONS$1;\n  }\n\n  var options = Object.assign({}, DEFAULT_OPTIONS$1, extraOptions); // fill default values\n  // TODO support pathes? nested.obj.list (walkSet)\n\n  var array = options.wait ? [] : ops.set(vm, key, []);\n  var originalResolve = resolve;\n  var isResolved; // contain ref subscriptions of objects\n  // arraySubs is a mirror of array\n\n  var arraySubs = [];\n  var change = {\n    added: function (_a) {\n      var newIndex = _a.newIndex,\n          doc = _a.doc;\n      arraySubs.splice(newIndex, 0, Object.create(null));\n      var subs = arraySubs[newIndex];\n\n      var _b = extractRefs(options.serialize(doc), undefined, subs),\n          data = _b[0],\n          refs = _b[1];\n\n      ops.add(array, newIndex, data);\n      subscribeToRefs(options, array, newIndex, subs, refs, ops, 0, resolve.bind(null, doc));\n    },\n    modified: function (_a) {\n      var oldIndex = _a.oldIndex,\n          newIndex = _a.newIndex,\n          doc = _a.doc;\n      var subs = arraySubs[oldIndex];\n      var oldData = array[oldIndex];\n\n      var _b = extractRefs(options.serialize(doc), oldData, subs),\n          data = _b[0],\n          refs = _b[1]; // only move things around after extracting refs\n      // only move things around after extracting refs\n\n\n      arraySubs.splice(newIndex, 0, subs);\n      ops.remove(array, oldIndex);\n      ops.add(array, newIndex, data);\n      subscribeToRefs(options, array, newIndex, subs, refs, ops, 0, resolve);\n    },\n    removed: function (_a) {\n      var oldIndex = _a.oldIndex;\n      ops.remove(array, oldIndex);\n      unsubscribeAll(arraySubs.splice(oldIndex, 1)[0]);\n    }\n  };\n  var unbind = collection.onSnapshot(function (snapshot) {\n    // console.log('pending', metadata.hasPendingWrites)\n    // docs.forEach(d => console.log('doc', d, '\\n', 'data', d.data()))\n    // NOTE: this will only be triggered once and it will be with all the documents\n    // from the query appearing as added\n    // (https://firebase.google.com/docs/firestore/query-data/listen#view_changes_between_snapshots)\n    var docChanges =\n    /* istanbul ignore next */\n    typeof snapshot.docChanges === 'function' ? snapshot.docChanges() :\n    /* istanbul ignore next to support firebase < 5*/\n    snapshot.docChanges;\n\n    if (!isResolved && docChanges.length) {\n      // isResolved is only meant to make sure we do the check only once\n      isResolved = true;\n      var count_1 = 0;\n      var expectedItems_1 = docChanges.length;\n      var validDocs_1 = Object.create(null);\n\n      for (var i = 0; i < expectedItems_1; i++) {\n        validDocs_1[docChanges[i].doc.id] = true;\n      }\n\n      resolve = function (_a) {\n        var id = _a.id;\n\n        if (id in validDocs_1) {\n          if (++count_1 >= expectedItems_1) {\n            // if wait is true, finally set the array\n            if (options.wait) ops.set(vm, key, array);\n            originalResolve(vm[key]); // reset resolve to noop\n\n            resolve = function () {};\n          }\n        }\n      };\n    }\n\n    docChanges.forEach(function (c) {\n      change[c.type](c);\n    }); // resolves when array is empty\n    // since this can only happen once, there is no need to guard against it\n    // being called multiple times\n\n    if (!docChanges.length) {\n      if (options.wait) ops.set(vm, key, array);\n      resolve(array);\n    }\n  }, reject);\n  return function (reset) {\n    unbind();\n\n    if (reset !== false) {\n      var value = typeof reset === 'function' ? reset() : [];\n      ops.set(vm, key, value);\n    }\n\n    arraySubs.forEach(unsubscribeAll);\n  };\n}\n/**\r\n * Binds a Document to a property of vm\r\n * @param param0\r\n * @param extraOptions\r\n */\n\n\nfunction bindDocument(_a, extraOptions) {\n  var vm = _a.vm,\n      key = _a.key,\n      document = _a.document,\n      resolve = _a.resolve,\n      reject = _a.reject,\n      ops = _a.ops;\n\n  if (extraOptions === void 0) {\n    extraOptions = DEFAULT_OPTIONS$1;\n  }\n\n  var options = Object.assign({}, DEFAULT_OPTIONS$1, extraOptions); // fill default values\n  // TODO: warning check if key exists?\n  // const boundRefs = Object.create(null)\n\n  var subs = Object.create(null); // bind here the function so it can be resolved anywhere\n  // this is specially useful for refs\n\n  resolve = callOnceWithArg(resolve, function () {\n    return walkGet(vm, key);\n  });\n  var unbind = document.onSnapshot(function (snapshot) {\n    if (snapshot.exists) {\n      updateDataFromDocumentSnapshot(options, vm, key, snapshot, subs, ops, 0, resolve);\n    } else {\n      ops.set(vm, key, null);\n      resolve(null);\n    }\n  }, reject);\n  return function (reset) {\n    unbind();\n\n    if (reset !== false) {\n      var value = typeof reset === 'function' ? reset() : null;\n      ops.set(vm, key, value);\n    }\n\n    unsubscribeAll(subs);\n  };\n}\n/**\r\n * Returns the original reference of a Firebase reference or query across SDK versions.\r\n *\r\n * @param {firebase.firebase.database.Reference|firebase.firebase.database.Query} refOrQuery\r\n * @return {firebase.firebase.database.Reference}\r\n */\n\n\nfunction getRef(refOrQuery) {\n  return refOrQuery.ref;\n}\n\nvar ops = {\n  set: function (target, key, value) {\n    return walkSet(target, key, value);\n  },\n  add: function (array, index, data) {\n    return array.splice(index, 0, data);\n  },\n  remove: function (array, index) {\n    return array.splice(index, 1);\n  }\n};\n\nfunction bind(vm, key, source, options) {\n  return new Promise(function (resolve, reject) {\n    var unbind;\n\n    if (Array.isArray(vm[key])) {\n      unbind = rtdbBindAsArray({\n        vm: vm,\n        key: key,\n        collection: source,\n        resolve: resolve,\n        reject: reject,\n        ops: ops\n      }, options);\n    } else {\n      unbind = rtdbBindAsObject({\n        vm: vm,\n        key: key,\n        document: source,\n        resolve: resolve,\n        reject: reject,\n        ops: ops\n      }, options);\n    }\n\n    vm._firebaseUnbinds[key] = unbind;\n  });\n}\n\nfunction unbind(vm, key, reset) {\n  vm._firebaseUnbinds[key](reset);\n\n  delete vm._firebaseSources[key];\n  delete vm._firebaseUnbinds[key];\n}\n\nvar defaultOptions = {\n  bindName: '$rtdbBind',\n  unbindName: '$rtdbUnbind',\n  serialize: DEFAULT_OPTIONS.serialize,\n  reset: DEFAULT_OPTIONS.reset,\n  wait: DEFAULT_OPTIONS.wait\n};\n\nvar rtdbPlugin = function rtdbPlugin(Vue, pluginOptions) {\n  if (pluginOptions === void 0) {\n    pluginOptions = defaultOptions;\n  }\n\n  var strategies = Vue.config.optionMergeStrategies;\n  strategies.firebase = strategies.provide;\n  var globalOptions = Object.assign({}, defaultOptions, pluginOptions);\n  var bindName = globalOptions.bindName,\n      unbindName = globalOptions.unbindName;\n\n  Vue.prototype[unbindName] = function rtdbUnbind(key, reset) {\n    unbind(this, key, reset);\n  }; // add $rtdbBind and $rtdbUnbind methods\n\n\n  Vue.prototype[bindName] = function rtdbBind(key, source, userOptions) {\n    var options = Object.assign({}, globalOptions, userOptions);\n\n    if (this._firebaseUnbinds[key]) {\n      // @ts-ignore\n      this[unbindName](key, // if wait, allow overriding with a function or reset, otherwise, force reset to false\n      // else pass the reset option\n      options.wait ? typeof options.reset === 'function' ? options.reset : false : options.reset);\n    }\n\n    var promise = bind(this, key, source, options); // @ts-ignore\n\n    this._firebaseSources[key] = source; // @ts-ignore\n\n    this.$firebaseRefs[key] = getRef(source);\n    return promise;\n  }; // handle firebase option\n\n\n  Vue.mixin({\n    beforeCreate: function () {\n      this.$firebaseRefs = Object.create(null);\n      this._firebaseSources = Object.create(null);\n      this._firebaseUnbinds = Object.create(null);\n    },\n    created: function () {\n      var bindings = this.$options.firebase;\n      if (typeof bindings === 'function') bindings = // @ts-ignore\n      bindings.call(this);\n      if (!bindings) return;\n\n      for (var key in bindings) {\n        // @ts-ignore\n        this[bindName](key, bindings[key], globalOptions);\n      }\n    },\n    beforeDestroy: function () {\n      for (var key in this._firebaseUnbinds) {\n        this._firebaseUnbinds[key]();\n      } // @ts-ignore\n\n\n      this._firebaseSources = null; // @ts-ignore\n\n      this._firebaseUnbinds = null; // @ts-ignore\n\n      this.$firebaseRefs = null;\n    }\n  });\n};\n\nvar ops$1 = {\n  set: function (target, key, value) {\n    return walkSet(target, key, value);\n  },\n  add: function (array, index, data) {\n    return array.splice(index, 0, data);\n  },\n  remove: function (array, index) {\n    return array.splice(index, 1);\n  }\n};\n\nfunction bind$1(vm, key, ref, ops, options) {\n  return new Promise(function (resolve, reject) {\n    var unbind;\n\n    if ('where' in ref) {\n      unbind = bindCollection({\n        vm: vm,\n        key: key,\n        ops: ops,\n        collection: ref,\n        resolve: resolve,\n        reject: reject\n      }, options);\n    } else {\n      unbind = bindDocument({\n        vm: vm,\n        key: key,\n        ops: ops,\n        document: ref,\n        resolve: resolve,\n        reject: reject\n      }, options);\n    }\n\n    vm._firestoreUnbinds[key] = unbind;\n  });\n}\n\nvar defaultOptions$1 = {\n  bindName: '$bind',\n  unbindName: '$unbind',\n  serialize: DEFAULT_OPTIONS$1.serialize,\n  reset: DEFAULT_OPTIONS$1.reset,\n  wait: DEFAULT_OPTIONS$1.wait\n};\n\nvar firestorePlugin = function firestorePlugin(Vue, pluginOptions) {\n  if (pluginOptions === void 0) {\n    pluginOptions = defaultOptions$1;\n  }\n\n  var strategies = Vue.config.optionMergeStrategies;\n  strategies.firestore = strategies.provide;\n  var globalOptions = Object.assign({}, defaultOptions$1, pluginOptions);\n  var bindName = globalOptions.bindName,\n      unbindName = globalOptions.unbindName;\n\n  Vue.prototype[unbindName] = function firestoreUnbind(key, reset) {\n    this._firestoreUnbinds[key](reset);\n\n    delete this._firestoreUnbinds[key];\n    delete this.$firestoreRefs[key];\n  };\n\n  Vue.prototype[bindName] = function firestoreBind(key, ref, userOptions) {\n    var options = Object.assign({}, globalOptions, userOptions);\n\n    if (this._firestoreUnbinds[key]) {\n      this[unbindName](key, // if wait, allow overriding with a function or reset, otherwise, force reset to false\n      // else pass the reset option\n      options.wait ? typeof options.reset === 'function' ? options.reset : false : options.reset);\n    }\n\n    var promise = bind$1(this, key, ref, ops$1, options); // @ts-ignore we are allowed to write it\n\n    this.$firestoreRefs[key] = ref;\n    return promise;\n  };\n\n  Vue.mixin({\n    beforeCreate: function () {\n      this._firestoreUnbinds = Object.create(null);\n      this.$firestoreRefs = Object.create(null);\n    },\n    created: function () {\n      var firestore = this.$options.firestore;\n      var refs = typeof firestore === 'function' ? firestore.call(this) : firestore;\n      if (!refs) return;\n\n      for (var key in refs) {\n        // @ts-ignore\n        this[bindName](key, refs[key], globalOptions);\n      }\n    },\n    beforeDestroy: function () {\n      for (var subKey in this._firestoreUnbinds) {\n        this._firestoreUnbinds[subKey]();\n      } // @ts-ignore we are allowed to write it\n\n\n      this._firestoreUnbinds = null; // @ts-ignore we are allowed to write it\n\n      this.$firestoreRefs = null;\n    }\n  });\n};\n\nexport { firestorePlugin, rtdbPlugin };","map":{"version":3,"names":["walkGet","obj","path","split","reduce","target","key","walkSet","value","keys","pop","Array","isArray","splice","Number","isObject","o","isTimestamp","toDate","isDocumentRef","onSnapshot","callOnceWithArg","fn","argFn","called","createRecordFromRTDBSnapshot","snapshot","val","res","Object","defineProperty","indexForKey","array","i","length","DEFAULT_OPTIONS","reset","serialize","wait","rtdbBindAsObject","_a","extraOptions","vm","document","resolve","reject","ops","options","assign","listener","on","set","once","off","rtdbBindAsArray","collection","childAdded","prevKey","index","add","childRemoved","remove","childChanged","childMoved","oldRecord","newIndex","data","createSnapshot","doc","id","extractRefs","oldDoc","subs","dataAndRefs","subsByPath","resultSubs","subKey","sub","recursiveExtract","result","refs","getOwnPropertyNames","forEach","propertyName","descriptor","getOwnPropertyDescriptor","enumerable","ref","Date","longitude","latitude","newRef","DEFAULT_OPTIONS$1","maxRefDepth","unsubscribeAll","unsub","updateDataFromDocumentSnapshot","depth","subscribeToRefs","subscribeToDocument","create","unbind","exists","refKeys","missingKeys","filter","refKey","indexOf","resolvedCount","totalToResolve","validResolves","deepResolve","docPath","bind","bindCollection","originalResolve","isResolved","arraySubs","change","added","_b","undefined","modified","oldIndex","oldData","removed","docChanges","count_1","expectedItems_1","validDocs_1","c","type","bindDocument","getRef","refOrQuery","source","Promise","_firebaseUnbinds","_firebaseSources","defaultOptions","bindName","unbindName","rtdbPlugin","Vue","pluginOptions","strategies","config","optionMergeStrategies","firebase","provide","globalOptions","prototype","rtdbUnbind","rtdbBind","userOptions","promise","$firebaseRefs","mixin","beforeCreate","created","bindings","$options","call","beforeDestroy","ops$1","bind$1","_firestoreUnbinds","defaultOptions$1","firestorePlugin","firestore","firestoreUnbind","$firestoreRefs","firestoreBind"],"sources":["C:/Users/keill/Desktop/mundialfifa-master/node_modules/vuefire/dist/vuefire.esm.js"],"sourcesContent":["/*!\n  * vuefire v2.2.5\n  * (c) 2020 Eduardo San Martin Morote\n  * @license MIT\n  */\n/**\r\n * Walks a path inside an object\r\n * walkGet({ a: { b: true }}), 'a.b') -> true\r\n * @param obj\r\n * @param path\r\n */\r\nfunction walkGet(obj, path) {\r\n    // TODO: development warning when target[key] does not exist\r\n    return path.split('.').reduce(function (target, key) { return target[key]; }, obj);\r\n}\r\n/**\r\n * Deeply set a property in an object with a string path\r\n * walkSet({ a: { b: true }}, 'a.b', false)\r\n * @param obj\r\n * @param path\r\n * @param value\r\n * @returns an array with the element that was replaced or the value that was set\r\n */\r\nfunction walkSet(obj, path, value) {\r\n    // path can be a number\r\n    var keys = ('' + path).split('.');\r\n    var key = keys.pop(); // split will produce at least one element array\r\n    var target = keys.reduce(function (target, key) {\r\n        // TODO: dev errors\r\n        return target[key];\r\n    }, obj);\r\n    return Array.isArray(target) ? target.splice(Number(key), 1, value) : (target[key] = value);\r\n}\r\n/**\r\n * Checks if a variable is an object\r\n * @param o\r\n */\r\nfunction isObject(o) {\r\n    return o && typeof o === 'object';\r\n}\r\n/**\r\n * Checks if a variable is a Date\r\n * @param o\r\n */\r\nfunction isTimestamp(o) {\r\n    return o.toDate;\r\n}\r\n/**\r\n * Checks if a variable is a Firestore Document Reference\r\n * @param o\r\n */\r\nfunction isDocumentRef(o) {\r\n    return o && o.onSnapshot;\r\n}\r\n/**\r\n * Wraps a function so it gets called only once\r\n * @param fn Function to be called once\r\n * @param argFn Function to compute the argument passed to fn\r\n */\r\nfunction callOnceWithArg(fn, argFn) {\r\n    /** @type {boolean | undefined} */\r\n    var called = false;\r\n    return function () {\r\n        if (!called) {\r\n            called = true;\r\n            return fn(argFn());\r\n        }\r\n    };\r\n}\n\n/**\r\n * Convert firebase RTDB snapshot into a bindable data record.\r\n *\r\n * @param snapshot\r\n * @return\r\n */\r\nfunction createRecordFromRTDBSnapshot(snapshot) {\r\n    var value = snapshot.val();\r\n    var res = isObject(value) ? value : Object.defineProperty({}, '.value', { value: value });\r\n    // if (isObject(value)) {\r\n    //   res = value\r\n    // } else {\r\n    //   res = {}\r\n    //   Object.defineProperty(res, '.value', { value })\r\n    // }\r\n    Object.defineProperty(res, '.key', { value: snapshot.key });\r\n    return res;\r\n}\r\n/**\r\n * Find the index for an object with given key.\r\n *\r\n * @param array\r\n * @param key\r\n * @return the index where the key was found\r\n */\r\nfunction indexForKey(array, key) {\r\n    for (var i = 0; i < array.length; i++) {\r\n        if (array[i]['.key'] === key)\r\n            return i;\r\n    }\r\n    return -1;\r\n}\n\nvar DEFAULT_OPTIONS = {\r\n    reset: true,\r\n    serialize: createRecordFromRTDBSnapshot,\r\n    wait: false,\r\n};\r\n/**\r\n * Binds a RTDB reference as an object\r\n * @param param0\r\n * @param options\r\n * @returns a function to be called to stop listeninng for changes\r\n */\r\nfunction rtdbBindAsObject(_a, extraOptions) {\r\n    var vm = _a.vm, key = _a.key, document = _a.document, resolve = _a.resolve, reject = _a.reject, ops = _a.ops;\r\n    if (extraOptions === void 0) { extraOptions = DEFAULT_OPTIONS; }\r\n    var options = Object.assign({}, DEFAULT_OPTIONS, extraOptions);\r\n    var listener = document.on('value', function (snapshot) {\r\n        ops.set(vm, key, options.serialize(snapshot));\r\n    }, reject);\r\n    document.once('value', resolve);\r\n    return function (reset) {\r\n        document.off('value', listener);\r\n        if (reset !== false) {\r\n            var value = typeof reset === 'function' ? reset() : null;\r\n            ops.set(vm, key, value);\r\n        }\r\n    };\r\n}\r\n/**\r\n * Binds a RTDB reference or query as an array\r\n * @param param0\r\n * @param options\r\n * @returns a function to be called to stop listeninng for changes\r\n */\r\nfunction rtdbBindAsArray(_a, extraOptions) {\r\n    var vm = _a.vm, key = _a.key, collection = _a.collection, resolve = _a.resolve, reject = _a.reject, ops = _a.ops;\r\n    if (extraOptions === void 0) { extraOptions = DEFAULT_OPTIONS; }\r\n    var options = Object.assign({}, DEFAULT_OPTIONS, extraOptions);\r\n    var array = options.wait ? [] : ops.set(vm, key, []);\r\n    var childAdded = collection.on('child_added', function (snapshot, prevKey) {\r\n        var index = prevKey ? indexForKey(array, prevKey) + 1 : 0;\r\n        ops.add(array, index, options.serialize(snapshot));\r\n    }, reject);\r\n    var childRemoved = collection.on('child_removed', function (snapshot) {\r\n        ops.remove(array, indexForKey(array, snapshot.key));\r\n    }, reject);\r\n    var childChanged = collection.on('child_changed', function (snapshot) {\r\n        ops.set(array, indexForKey(array, snapshot.key), options.serialize(snapshot));\r\n    }, reject);\r\n    var childMoved = collection.on('child_moved', function (snapshot, prevKey) {\r\n        var index = indexForKey(array, snapshot.key);\r\n        var oldRecord = ops.remove(array, index)[0];\r\n        var newIndex = prevKey ? indexForKey(array, prevKey) + 1 : 0;\r\n        ops.add(array, newIndex, oldRecord);\r\n    }, reject);\r\n    collection.once('value', function (data) {\r\n        if (options.wait)\r\n            ops.set(vm, key, array);\r\n        resolve(data);\r\n    });\r\n    return function (reset) {\r\n        collection.off('child_added', childAdded);\r\n        collection.off('child_changed', childChanged);\r\n        collection.off('child_removed', childRemoved);\r\n        collection.off('child_moved', childMoved);\r\n        if (reset !== false) {\r\n            var value = typeof reset === 'function' ? reset() : [];\r\n            ops.set(vm, key, value);\r\n        }\r\n    };\r\n}\n\n// TODO: fix type not to be any\r\nfunction createSnapshot(doc) {\r\n    // TODO: it should create a deep copy instead because otherwise we will modify internal data\r\n    // defaults everything to false, so no need to set\r\n    return Object.defineProperty(doc.data() || {}, 'id', { value: doc.id });\r\n}\r\nfunction extractRefs(doc, oldDoc, subs) {\r\n    var dataAndRefs = [{}, {}];\r\n    var subsByPath = Object.keys(subs).reduce(function (resultSubs, subKey) {\r\n        var sub = subs[subKey];\r\n        resultSubs[sub.path] = sub.data();\r\n        return resultSubs;\r\n    }, {});\r\n    function recursiveExtract(doc, oldDoc, path, result) {\r\n        // make it easier to later on access the value\r\n        oldDoc = oldDoc || {};\r\n        var data = result[0], refs = result[1];\r\n        // Add all properties that are not enumerable (not visible in the for loop)\r\n        // getOwnPropertyDescriptors does not exist on IE\r\n        Object.getOwnPropertyNames(doc).forEach(function (propertyName) {\r\n            var descriptor = Object.getOwnPropertyDescriptor(doc, propertyName);\r\n            if (descriptor && !descriptor.enumerable) {\r\n                Object.defineProperty(data, propertyName, descriptor);\r\n            }\r\n        });\r\n        // recursively traverse doc to copy values and extract references\r\n        for (var key in doc) {\r\n            var ref = doc[key];\r\n            if (\r\n            // primitives\r\n            ref == null ||\r\n                // Firestore < 4.13\r\n                ref instanceof Date ||\r\n                isTimestamp(ref) ||\r\n                (ref.longitude && ref.latitude) // GeoPoint\r\n            ) {\r\n                data[key] = ref;\r\n            }\r\n            else if (isDocumentRef(ref)) {\r\n                // allow values to be null (like non-existant refs)\r\n                // TODO: better typing since this isObject shouldn't be necessary but it doesn't work\r\n                data[key] =\r\n                    typeof oldDoc === 'object' &&\r\n                        key in oldDoc &&\r\n                        // only copy refs if they were refs before\r\n                        // https://github.com/vuejs/vuefire/issues/831\r\n                        typeof oldDoc[key] != 'string'\r\n                        ? oldDoc[key]\r\n                        : ref.path;\r\n                // TODO: handle subpathes?\r\n                refs[path + key] = ref;\r\n            }\r\n            else if (Array.isArray(ref)) {\r\n                data[key] = Array(ref.length);\r\n                // fill existing refs into data but leave the rest empty\r\n                for (var i = 0; i < ref.length; i++) {\r\n                    var newRef = ref[i];\r\n                    // TODO: this only works with array of primitives but not with nested properties like objects with References\r\n                    if (newRef && newRef.path in subsByPath)\r\n                        data[key][i] = subsByPath[newRef.path];\r\n                }\r\n                // the oldArray is in this case the same array with holes unless the array already existed\r\n                recursiveExtract(ref, oldDoc[key] || data[key], path + key + '.', [data[key], refs]);\r\n            }\r\n            else if (isObject(ref)) {\r\n                data[key] = {};\r\n                recursiveExtract(ref, oldDoc[key], path + key + '.', [data[key], refs]);\r\n            }\r\n            else {\r\n                data[key] = ref;\r\n            }\r\n        }\r\n    }\r\n    recursiveExtract(doc, oldDoc, '', dataAndRefs);\r\n    return dataAndRefs;\r\n}\n\nvar DEFAULT_OPTIONS$1 = {\r\n    maxRefDepth: 2,\r\n    reset: true,\r\n    serialize: createSnapshot,\r\n    wait: false,\r\n};\r\nfunction unsubscribeAll(subs) {\r\n    for (var sub in subs) {\r\n        subs[sub].unsub();\r\n    }\r\n}\r\nfunction updateDataFromDocumentSnapshot(options, target, path, snapshot, subs, ops, depth, resolve) {\r\n    var _a = extractRefs(options.serialize(snapshot), walkGet(target, path), subs), data = _a[0], refs = _a[1];\r\n    ops.set(target, path, data);\r\n    subscribeToRefs(options, target, path, subs, refs, ops, depth, resolve);\r\n}\r\nfunction subscribeToDocument(_a, options) {\r\n    var ref = _a.ref, target = _a.target, path = _a.path, depth = _a.depth, resolve = _a.resolve, ops = _a.ops;\r\n    var subs = Object.create(null);\r\n    var unbind = ref.onSnapshot(function (snapshot) {\r\n        if (snapshot.exists) {\r\n            updateDataFromDocumentSnapshot(options, target, path, snapshot, subs, ops, depth, resolve);\r\n        }\r\n        else {\r\n            ops.set(target, path, null);\r\n            resolve();\r\n        }\r\n    });\r\n    return function () {\r\n        unbind();\r\n        unsubscribeAll(subs);\r\n    };\r\n}\r\n// NOTE: not convinced by the naming of subscribeToRefs and subscribeToDocument\r\n// first one is calling the other on every ref and subscribeToDocument may call\r\n// updateDataFromDocumentSnapshot which may call subscribeToRefs as well\r\nfunction subscribeToRefs(options, target, path, subs, refs, ops, depth, resolve) {\r\n    var refKeys = Object.keys(refs);\r\n    var missingKeys = Object.keys(subs).filter(function (refKey) { return refKeys.indexOf(refKey) < 0; });\r\n    // unbind keys that are no longer there\r\n    missingKeys.forEach(function (refKey) {\r\n        subs[refKey].unsub();\r\n        delete subs[refKey];\r\n    });\r\n    if (!refKeys.length || ++depth > options.maxRefDepth)\r\n        return resolve(path);\r\n    var resolvedCount = 0;\r\n    var totalToResolve = refKeys.length;\r\n    var validResolves = Object.create(null);\r\n    function deepResolve(key) {\r\n        if (key in validResolves) {\r\n            if (++resolvedCount >= totalToResolve)\r\n                resolve(path);\r\n        }\r\n    }\r\n    refKeys.forEach(function (refKey) {\r\n        var sub = subs[refKey];\r\n        var ref = refs[refKey];\r\n        var docPath = path + \".\" + refKey;\r\n        validResolves[docPath] = true;\r\n        // unsubscribe if bound to a different ref\r\n        if (sub) {\r\n            if (sub.path !== ref.path)\r\n                sub.unsub();\r\n            // if has already be bound and as we always walk the objects, it will work\r\n            else\r\n                return;\r\n        }\r\n        subs[refKey] = {\r\n            data: function () { return walkGet(target, docPath); },\r\n            unsub: subscribeToDocument({\r\n                ref: ref,\r\n                target: target,\r\n                path: docPath,\r\n                depth: depth,\r\n                ops: ops,\r\n                resolve: deepResolve.bind(null, docPath),\r\n            }, options),\r\n            path: ref.path,\r\n        };\r\n    });\r\n}\r\n// TODO: refactor without using an object to improve size like the other functions\r\nfunction bindCollection(_a, extraOptions) {\r\n    var vm = _a.vm, key = _a.key, collection = _a.collection, ops = _a.ops, resolve = _a.resolve, reject = _a.reject;\r\n    if (extraOptions === void 0) { extraOptions = DEFAULT_OPTIONS$1; }\r\n    var options = Object.assign({}, DEFAULT_OPTIONS$1, extraOptions); // fill default values\r\n    // TODO support pathes? nested.obj.list (walkSet)\r\n    var array = options.wait ? [] : ops.set(vm, key, []);\r\n    var originalResolve = resolve;\r\n    var isResolved;\r\n    // contain ref subscriptions of objects\r\n    // arraySubs is a mirror of array\r\n    var arraySubs = [];\r\n    var change = {\r\n        added: function (_a) {\r\n            var newIndex = _a.newIndex, doc = _a.doc;\r\n            arraySubs.splice(newIndex, 0, Object.create(null));\r\n            var subs = arraySubs[newIndex];\r\n            var _b = extractRefs(options.serialize(doc), undefined, subs), data = _b[0], refs = _b[1];\r\n            ops.add(array, newIndex, data);\r\n            subscribeToRefs(options, array, newIndex, subs, refs, ops, 0, resolve.bind(null, doc));\r\n        },\r\n        modified: function (_a) {\r\n            var oldIndex = _a.oldIndex, newIndex = _a.newIndex, doc = _a.doc;\r\n            var subs = arraySubs[oldIndex];\r\n            var oldData = array[oldIndex];\r\n            var _b = extractRefs(options.serialize(doc), oldData, subs), data = _b[0], refs = _b[1];\r\n            // only move things around after extracting refs\r\n            // only move things around after extracting refs\r\n            arraySubs.splice(newIndex, 0, subs);\r\n            ops.remove(array, oldIndex);\r\n            ops.add(array, newIndex, data);\r\n            subscribeToRefs(options, array, newIndex, subs, refs, ops, 0, resolve);\r\n        },\r\n        removed: function (_a) {\r\n            var oldIndex = _a.oldIndex;\r\n            ops.remove(array, oldIndex);\r\n            unsubscribeAll(arraySubs.splice(oldIndex, 1)[0]);\r\n        },\r\n    };\r\n    var unbind = collection.onSnapshot(function (snapshot) {\r\n        // console.log('pending', metadata.hasPendingWrites)\r\n        // docs.forEach(d => console.log('doc', d, '\\n', 'data', d.data()))\r\n        // NOTE: this will only be triggered once and it will be with all the documents\r\n        // from the query appearing as added\r\n        // (https://firebase.google.com/docs/firestore/query-data/listen#view_changes_between_snapshots)\r\n        var docChanges = \r\n        /* istanbul ignore next */\r\n        typeof snapshot.docChanges === 'function'\r\n            ? snapshot.docChanges()\r\n            : /* istanbul ignore next to support firebase < 5*/\r\n                snapshot.docChanges;\r\n        if (!isResolved && docChanges.length) {\r\n            // isResolved is only meant to make sure we do the check only once\r\n            isResolved = true;\r\n            var count_1 = 0;\r\n            var expectedItems_1 = docChanges.length;\r\n            var validDocs_1 = Object.create(null);\r\n            for (var i = 0; i < expectedItems_1; i++) {\r\n                validDocs_1[docChanges[i].doc.id] = true;\r\n            }\r\n            resolve = function (_a) {\r\n                var id = _a.id;\r\n                if (id in validDocs_1) {\r\n                    if (++count_1 >= expectedItems_1) {\r\n                        // if wait is true, finally set the array\r\n                        if (options.wait)\r\n                            ops.set(vm, key, array);\r\n                        originalResolve(vm[key]);\r\n                        // reset resolve to noop\r\n                        resolve = function () { };\r\n                    }\r\n                }\r\n            };\r\n        }\r\n        docChanges.forEach(function (c) {\r\n            change[c.type](c);\r\n        });\r\n        // resolves when array is empty\r\n        // since this can only happen once, there is no need to guard against it\r\n        // being called multiple times\r\n        if (!docChanges.length) {\r\n            if (options.wait)\r\n                ops.set(vm, key, array);\r\n            resolve(array);\r\n        }\r\n    }, reject);\r\n    return function (reset) {\r\n        unbind();\r\n        if (reset !== false) {\r\n            var value = typeof reset === 'function' ? reset() : [];\r\n            ops.set(vm, key, value);\r\n        }\r\n        arraySubs.forEach(unsubscribeAll);\r\n    };\r\n}\r\n/**\r\n * Binds a Document to a property of vm\r\n * @param param0\r\n * @param extraOptions\r\n */\r\nfunction bindDocument(_a, extraOptions) {\r\n    var vm = _a.vm, key = _a.key, document = _a.document, resolve = _a.resolve, reject = _a.reject, ops = _a.ops;\r\n    if (extraOptions === void 0) { extraOptions = DEFAULT_OPTIONS$1; }\r\n    var options = Object.assign({}, DEFAULT_OPTIONS$1, extraOptions); // fill default values\r\n    // TODO: warning check if key exists?\r\n    // const boundRefs = Object.create(null)\r\n    var subs = Object.create(null);\r\n    // bind here the function so it can be resolved anywhere\r\n    // this is specially useful for refs\r\n    resolve = callOnceWithArg(resolve, function () { return walkGet(vm, key); });\r\n    var unbind = document.onSnapshot(function (snapshot) {\r\n        if (snapshot.exists) {\r\n            updateDataFromDocumentSnapshot(options, vm, key, snapshot, subs, ops, 0, resolve);\r\n        }\r\n        else {\r\n            ops.set(vm, key, null);\r\n            resolve(null);\r\n        }\r\n    }, reject);\r\n    return function (reset) {\r\n        unbind();\r\n        if (reset !== false) {\r\n            var value = typeof reset === 'function' ? reset() : null;\r\n            ops.set(vm, key, value);\r\n        }\r\n        unsubscribeAll(subs);\r\n    };\r\n}\n\n/**\r\n * Returns the original reference of a Firebase reference or query across SDK versions.\r\n *\r\n * @param {firebase.firebase.database.Reference|firebase.firebase.database.Query} refOrQuery\r\n * @return {firebase.firebase.database.Reference}\r\n */\r\nfunction getRef(refOrQuery) {\r\n    return refOrQuery.ref;\r\n}\r\nvar ops = {\r\n    set: function (target, key, value) { return walkSet(target, key, value); },\r\n    add: function (array, index, data) { return array.splice(index, 0, data); },\r\n    remove: function (array, index) { return array.splice(index, 1); },\r\n};\r\nfunction bind(vm, key, source, options) {\r\n    return new Promise(function (resolve, reject) {\r\n        var unbind;\r\n        if (Array.isArray(vm[key])) {\r\n            unbind = rtdbBindAsArray({\r\n                vm: vm,\r\n                key: key,\r\n                collection: source,\r\n                resolve: resolve,\r\n                reject: reject,\r\n                ops: ops,\r\n            }, options);\r\n        }\r\n        else {\r\n            unbind = rtdbBindAsObject({\r\n                vm: vm,\r\n                key: key,\r\n                document: source,\r\n                resolve: resolve,\r\n                reject: reject,\r\n                ops: ops,\r\n            }, options);\r\n        }\r\n        vm._firebaseUnbinds[key] = unbind;\r\n    });\r\n}\r\nfunction unbind(vm, key, reset) {\r\n    vm._firebaseUnbinds[key](reset);\r\n    delete vm._firebaseSources[key];\r\n    delete vm._firebaseUnbinds[key];\r\n}\r\nvar defaultOptions = {\r\n    bindName: '$rtdbBind',\r\n    unbindName: '$rtdbUnbind',\r\n    serialize: DEFAULT_OPTIONS.serialize,\r\n    reset: DEFAULT_OPTIONS.reset,\r\n    wait: DEFAULT_OPTIONS.wait,\r\n};\r\nvar rtdbPlugin = function rtdbPlugin(Vue, pluginOptions) {\r\n    if (pluginOptions === void 0) { pluginOptions = defaultOptions; }\r\n    var strategies = Vue.config.optionMergeStrategies;\r\n    strategies.firebase = strategies.provide;\r\n    var globalOptions = Object.assign({}, defaultOptions, pluginOptions);\r\n    var bindName = globalOptions.bindName, unbindName = globalOptions.unbindName;\r\n    Vue.prototype[unbindName] = function rtdbUnbind(key, reset) {\r\n        unbind(this, key, reset);\r\n    };\r\n    // add $rtdbBind and $rtdbUnbind methods\r\n    Vue.prototype[bindName] = function rtdbBind(key, source, userOptions) {\r\n        var options = Object.assign({}, globalOptions, userOptions);\r\n        if (this._firebaseUnbinds[key]) {\r\n            // @ts-ignore\r\n            this[unbindName](key, \r\n            // if wait, allow overriding with a function or reset, otherwise, force reset to false\r\n            // else pass the reset option\r\n            options.wait ? (typeof options.reset === 'function' ? options.reset : false) : options.reset);\r\n        }\r\n        var promise = bind(this, key, source, options);\r\n        // @ts-ignore\r\n        this._firebaseSources[key] = source;\r\n        // @ts-ignore\r\n        this.$firebaseRefs[key] = getRef(source);\r\n        return promise;\r\n    };\r\n    // handle firebase option\r\n    Vue.mixin({\r\n        beforeCreate: function () {\r\n            this.$firebaseRefs = Object.create(null);\r\n            this._firebaseSources = Object.create(null);\r\n            this._firebaseUnbinds = Object.create(null);\r\n        },\r\n        created: function () {\r\n            var bindings = this.$options.firebase;\r\n            if (typeof bindings === 'function')\r\n                bindings =\r\n                    // @ts-ignore\r\n                    bindings.call(this);\r\n            if (!bindings)\r\n                return;\r\n            for (var key in bindings) {\r\n                // @ts-ignore\r\n                this[bindName](key, bindings[key], globalOptions);\r\n            }\r\n        },\r\n        beforeDestroy: function () {\r\n            for (var key in this._firebaseUnbinds) {\r\n                this._firebaseUnbinds[key]();\r\n            }\r\n            // @ts-ignore\r\n            this._firebaseSources = null;\r\n            // @ts-ignore\r\n            this._firebaseUnbinds = null;\r\n            // @ts-ignore\r\n            this.$firebaseRefs = null;\r\n        },\r\n    });\r\n};\n\nvar ops$1 = {\r\n    set: function (target, key, value) { return walkSet(target, key, value); },\r\n    add: function (array, index, data) { return array.splice(index, 0, data); },\r\n    remove: function (array, index) { return array.splice(index, 1); },\r\n};\r\nfunction bind$1(vm, key, ref, ops, options) {\r\n    return new Promise(function (resolve, reject) {\r\n        var unbind;\r\n        if ('where' in ref) {\r\n            unbind = bindCollection({\r\n                vm: vm,\r\n                key: key,\r\n                ops: ops,\r\n                collection: ref,\r\n                resolve: resolve,\r\n                reject: reject,\r\n            }, options);\r\n        }\r\n        else {\r\n            unbind = bindDocument({\r\n                vm: vm,\r\n                key: key,\r\n                ops: ops,\r\n                document: ref,\r\n                resolve: resolve,\r\n                reject: reject,\r\n            }, options);\r\n        }\r\n        vm._firestoreUnbinds[key] = unbind;\r\n    });\r\n}\r\nvar defaultOptions$1 = {\r\n    bindName: '$bind',\r\n    unbindName: '$unbind',\r\n    serialize: DEFAULT_OPTIONS$1.serialize,\r\n    reset: DEFAULT_OPTIONS$1.reset,\r\n    wait: DEFAULT_OPTIONS$1.wait,\r\n};\r\nvar firestorePlugin = function firestorePlugin(Vue, pluginOptions) {\r\n    if (pluginOptions === void 0) { pluginOptions = defaultOptions$1; }\r\n    var strategies = Vue.config.optionMergeStrategies;\r\n    strategies.firestore = strategies.provide;\r\n    var globalOptions = Object.assign({}, defaultOptions$1, pluginOptions);\r\n    var bindName = globalOptions.bindName, unbindName = globalOptions.unbindName;\r\n    Vue.prototype[unbindName] = function firestoreUnbind(key, reset) {\r\n        this._firestoreUnbinds[key](reset);\r\n        delete this._firestoreUnbinds[key];\r\n        delete this.$firestoreRefs[key];\r\n    };\r\n    Vue.prototype[bindName] = function firestoreBind(key, ref, userOptions) {\r\n        var options = Object.assign({}, globalOptions, userOptions);\r\n        if (this._firestoreUnbinds[key]) {\r\n            this[unbindName](key, \r\n            // if wait, allow overriding with a function or reset, otherwise, force reset to false\r\n            // else pass the reset option\r\n            options.wait ? (typeof options.reset === 'function' ? options.reset : false) : options.reset);\r\n        }\r\n        var promise = bind$1(this, key, ref, ops$1, options);\r\n        // @ts-ignore we are allowed to write it\r\n        this.$firestoreRefs[key] = ref;\r\n        return promise;\r\n    };\r\n    Vue.mixin({\r\n        beforeCreate: function () {\r\n            this._firestoreUnbinds = Object.create(null);\r\n            this.$firestoreRefs = Object.create(null);\r\n        },\r\n        created: function () {\r\n            var firestore = this.$options.firestore;\r\n            var refs = typeof firestore === 'function' ? firestore.call(this) : firestore;\r\n            if (!refs)\r\n                return;\r\n            for (var key in refs) {\r\n                // @ts-ignore\r\n                this[bindName](key, refs[key], globalOptions);\r\n            }\r\n        },\r\n        beforeDestroy: function () {\r\n            for (var subKey in this._firestoreUnbinds) {\r\n                this._firestoreUnbinds[subKey]();\r\n            }\r\n            // @ts-ignore we are allowed to write it\r\n            this._firestoreUnbinds = null;\r\n            // @ts-ignore we are allowed to write it\r\n            this.$firestoreRefs = null;\r\n        },\r\n    });\r\n};\n\nexport { firestorePlugin, rtdbPlugin };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}